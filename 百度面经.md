### 百度面经

#### 一面

一直深挖项目，挖了快半小时。然后再写两道题，最后再问一些简单的问题。

**算法：**判断是否为镜面二叉树
**算法：**二叉树的俯视图
**一个协程被网络io卡住了，对应的线程会不会卡住？**
不会。因为都用epoll那是非阻塞调用，网络io和系统调用不一样的处理方式。网络io 是利用非阻塞，系统调用会创建新的线程来接管其他 goroutine。

**go 里面 make 和 new 有什么区别？**
make 一般用来创建引用类型 slice、map 以及 channel 等等，并且是非零值的。而new 用于类型的内存分配，并且内存置为零。make 返回的是引用类型本身；而 new 返回的是指向类型的指针。

**map 是怎么实现的？**
map 的底层是一个结构体

~~~go
// Go map 的底层结构体表示
type hmap struct {
    count     int    // map中键值对的个数，使用len()可以获取 
	flags     uint8
	B         uint8  // 哈希桶的数量的log2，比如有8个桶，那么B=3
	noverflow uint16 // 溢出桶的数量
	hash0     uint32 // 哈希种子

	buckets    unsafe.Pointer // 指向哈希桶数组的指针，数量为 2^B 
	oldbuckets unsafe.Pointer // 扩容时指向旧桶的指针，当扩容时不为nil 
	nevacuate  uintptr        
	
	extra *mapextra  // 可选字段
}
const (
	bucketCntBits = 3
	bucketCnt     = 1 << bucketCntBits     // 桶数量 1 << 3 = 8
)

// Go map 的一个哈希桶，一个桶最多存放8个键值对
type bmap struct {
    // tophash存放了哈希值的最高字节
	tophash [bucketCnt]uint8
    

    // 在这里有几个其它的字段没有显示出来，因为k-v的数量类型是不确定的，编译的时候才会确定
    // keys: 是一个数组，大小为bucketCnt=8，存放Key
    // elems: 是一个数组，大小为bucketCnt=8，存放Value
    // 你可能会想到为什么不用空接口，空接口可以保存任意类型。但是空接口底层也是个结构体，中间隔了一层。因此在这里没有使用空接口。
    // 注意：之所以将所有key存放在一个数组，将value存放在一个数组，而不是键值对的形式，是为了消除例如map[int64]所需的填充整数8（内存对齐）
    
    // overflow: 是一个指针，指向溢出桶，当该桶不够用时，就会使用溢出桶

}

~~~




当向 map 中存储一个 kv 时，通过 k 的 hash 值与 buckets 长度取余，定位到 key 在哪一个bucket中，hash 值的高8位存储在 bucket 的 tophash[i] 中，用来快速判断 key是否存在。当一个 bucket 满时，通过 overflow 指针链接到下一个 bucket。

#### 二面

又深挖项目，这次挖了快40分钟了。。

**go里面 slice 和 array 有区别吗？**
slice， 是切片，是引用类型，长度可变。
array，是数组，是值类型，长度不可变。

slice的底层其实是基于array 实现的。

**归并排序是稳定的吗？时间复杂度是多少？**
是的，归并排序中相等元素的顺序不会改变。

总时间 = 分解时间+解决问题时间+合并时间。

分解时间就是把一个待排序序列分解成两序列，时间为一常数，时间复杂度o(1)。
解决问题时间是两个递归式，把一个规模为n 的问题分成两个规模分别为 n/2 的子问题，时间为2T(n/2)。
合并时间复杂度为o(n)。
总时间T(n)=2T(n/2)+o(n)，这个递归式可以用递归树来解，其解是o(nlogn)。
所以是O(nlogn)

**写一个归并排序吧**

~~~go
func mergeSort(arr *[]int, l int, r int) {
	if l >= r {
		//不可再分隔,只有一个元素
		return
	}
	mid := (l+r)/2
	mergeSort(arr,l,mid)
	mergeSort(arr,mid+1,r)
	if (*arr)[mid] > (*arr)[mid+1] {
		merge(arr, l, mid, r)
	}
}

//将arr[l...mid]和arr[mid+1...r]两部分进行归并
func merge(arr *[]int, l int, mid int, r int)  {
	//先把arr中[l..r]区间的值copy一份到arr2
	//注意:这里可优化，copyarr 可改为长度为r-l+1的数组,下面的赋值等操作按偏移量l来修改即可，
	copyarr := make([]int, r+1)
	for index := l; index <= r; index++ {
		copyarr[index] = (*arr)[index]
	}
	//定义要合并的两个子数组各自目前数组内还没被合并的首位数字下标为i,j
	//初始化i，j
	i := l
	j := mid+1
	//遍历并逐个确定数组[l,r]区间内数字的顺序
	for k := l; k <= r; k++ {
		//防止i/j"越界"，应该先判断i和j的下变是否符合条件（因为两个子数组应该符合i<=mid j<=r）
		if i > mid {
			(*arr)[k] = copyarr[j]
			j++
		}else if j > r {
			(*arr)[k] = copyarr[i]
			i++
		}else if copyarr[i] < copyarr[j] {
			(*arr)[k] = copyarr[i]
			i++
		}else{
			(*arr)[k] = copyarr[j]
			j++
		}
	}
}

func TestMerge(t *testing.T) {
	arr := []int{8,6,2,3,1,5,7,4}
	mergeSort(&arr, 0, len(arr)-1)
	fmt.Println(arr)
}
~~~



**空chan和关闭的chan进行读写会怎么样？**

- 空chan:读会读取到该chan类型的零值。写会直接写到chan中。

- 关闭的chan:读已经关闭的 chan 能一直读到东西，但是读到的内容根据通道内关闭前是否有元素而不同。如果有元素，就继续读剩下的元素，如果没有就是这个chan类型的零值，比如整型是 int，字符串是"" 。
- 写已经关闭的 chan 会 panic。因为源码上面就是这样写的，可以看src/runtime/chan.go

#### 三面

感觉就走个过场。。面完简历就共享了。。

**讲讲redis分布式锁的设计与实现**
这篇博客很详细了，可以看这篇博客 redis分布式锁实现

**讲讲redis的哨兵模式**
一主两从三哨兵集群，当 master 节点宕机时，通过哨兵(sentinel)重新推选出新的master节点，保证集群的可用性。



**限流算法有哪些？令牌桶算法怎么实现？**

- 限流算法常见有计数器算法，滑动窗口，令牌桶算法。

- 令牌桶算法是比较常见的限流算法之一，如下：

  - 所有的请求在处理之前都需要拿到一个可用的令牌才会被处理；


  - 根据限流大小，设置按照一定的速率往桶里添加令牌；

  - 桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝；

  - 请求达到后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除；

  - 令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流；

**算法：交换二叉树左右节点**

## **如果线上流量暴增，全都打到一个 upstream 上了，怎么排查。**

线上流量暴增，所有请求都打到一个upstream（通常指后端服务器集群中的一个节点或服务）上时，可能是因为负载均衡配置问题或后端服务问题。以下是一些排查步骤：
### 1. 确认问题现象
- **监控检查**：查看监控系统，确认流量是否真的只打到了一个upstream。
- **日志分析**：查看访问日志和错误日志，确认请求是否确实只路由到了单一节点。
### 2. 检查负载均衡器
- **负载均衡配置**：检查负载均衡器（如Nginx, HAProxy等）的配置文件，确认是否正确设置了负载均衡策略（如轮询、IP哈希等）。
- **健康检查**：确认负载均衡器的健康检查机制是否正常工作，是否因为其他节点被认为不健康而被排除。
- **会话保持**：如果使用了会话保持功能，检查是否配置不当导致所有会话都路由到了同一个节点。
### 3. 检查后端服务
- **服务状态**：检查后端服务的状态，确认是否有服务故障或性能问题导致请求集中。
- **资源使用情况**：查看后端节点的CPU、内存、磁盘I/O和网络使用情况，确认是否有资源瓶颈。
- **代码和配置**：检查代码和配置是否有变更，可能导致请求处理缓慢或失败。
### 4. 网络问题
- **网络延迟和丢包**：使用网络诊断工具（如ping, mtr, tcpdump等）检查网络延迟和丢包情况。
- **防火墙和路由**：检查网络防火墙规则和路由配置，确认是否有规则导致流量集中。
### 5. 临时解决方案
- **手动切换**：如果配置没有问题，可以尝试手动切换负载均衡策略或重启负载均衡器。
- **增加节点**：如果条件允许，可以临时增加后端服务节点来分担流量。
### 6. 长期解决方案
- **优化配置**：根据排查结果优化负载均衡器的配置。
- **扩展资源**：根据流量情况增加后端服务节点的资源或数量。
- **应急预案**：制定应对突发流量的应急预案，以便快速响应。
### 7. 日志和监控
- **日志记录**：确保所有相关组件都有详细的日志记录，以便于问题追踪。
- **监控告警**：设置合理的监控指标和告警规则，以便在问题发生时能够及时发现。
通过上述步骤，应该能够定位到流量集中的原因，并采取相应的措施进行修复。记得在问题解决后，回顾整个事件，更新文档和应急预案，以防止类似问题再次发生。

### 社招百度一面

百度的面试步骤分为计算机基础、go 相关、mysql 相关、redis 相关、linux 相关问题。还有一些发散性的问题。

基础相关
算法，包括不限于红黑树、二叉树等等。
数据结构，包括不限于链表、数组等。
tcp、ip 相关的一些问题，比如三次握手、四次挥手、time_wait 等等。
浏览器输入地址，中间发生的过程，仔细的描述一下。（这个我感觉基本都会被问，哈哈哈）。
这一块的话，我回答的是稀碎，算法和数据结构我一个都没答上来，后面两个因为之前面试问到过，所以查过一些，回答的还算可以。

go 相关
GC，（面 GO 必问题），GC 中 stw 时机，各个阶段是如何解决的。
gpm，（面 GO 必问题），这个必须要完全理解，抢占式调度是如何抢占的，怎么调度 goroutine 的，M 和 P 的数量问题。
如何优雅的实现一个 goroutine 池（这个回答的稀碎）
谈谈内存逃逸
内存管理（这个也回答的稀碎）
mysql 相关
mysql 锁，分锁粒度和锁算法（间隙锁、记录锁，临键锁），以及锁算法在什么情况下会用到。大概意思就是如果精准能匹配到的话，用的就是记录锁，否则退化为间隙锁
mysql mvvc 实现原理。
mysql 索引，索引建立时机，建立规则。
mysql 分库分表规则，有没有实践过？
mysql 索引的类型以及索引的数据结构
mysql 事务特性，以及隔离级别。
redis
redis 的数据类型有哪些，使用场景说说。
redis zset 的编码方式，应该有两种，在配置文件中配置的，默认 128 个元素是 ziplist（压缩表），大于 128 则是 skiplist
redis 的内存淘汰策略
redis 的持久化策略
redis 分布式锁
redis 分布式架构有哪些
如果有一个排行榜，用 zset，根据积分和时间来排序，积分高的，时间最近的拍前面，怎么实现？
linux
你熟悉的有哪些命令
如果线上流量暴增，全都打到一个 upstream 上了，怎么排查。
如何在 nginx 的 access log 中查出请求前 10 的 ip
总结
我面试结束后，一般都会问面试官，根据这次面试，针对我的技术上面，有什么好的建议或者意见，这位面试官给我的回答是：计算机基础比较薄弱，但是业务能力很强。这也是我目前的现状，哈哈，所以最近一直在看哈工大老师的计算机理论和操作系统。希望能勤能补拙吧。

米哈游一面
米哈游面试总体分为四个部分，go 相关，mysql 相关，redis 相关，linux 相关。

go 相关
第一题就给我干懵逼了。代码如下：
~~~go
m := make(map[int]int, 10)
for i := 1; i<= 10; i++ {
    m[i] = i
}
for k, v := range(m) {
    go func() {
        fmt.Println("k ->", k, "v ->", v)
    }()
}
~~~



问会出现什么状况，为什么，怎么解决。就是不要闭包直接使用外部变量，通过传参就能解决了。

内存泄露，什么情况下内存会泄露。
channel 的底层实现原理，（其实就是问 buf 是环形链表的数据结构）
defer，这个一定要认真回答，defer 在什么时机会修改返回值。多个 defer 的顺序。
make 和 new 的区别
channel 关闭了接着 send 数据会发生什么，关闭一个已经关闭的 channel 会发生什么。
map 是线程安全的吗，map 的扩容规则。
数组和切片的区别。
GC
GPM 模型
进程、线程、协程区别。（这个很重要）
还有其他的我忘记了。

redis
差不多就是百度那样。

mysql
也差不多和百度那样。

linux
大差不差，就问了一个怎么根据进程名查该进程的 id.

总结
根据面试反馈来看，米哈游给出的是 go 基础较差，但是业务能力较强。可能这就是之前干外包的特点吧。

米哈游的二面
米哈游二面主要问的是业务方面和算法方面的问题，主要有三部分。

微服务相关，包括微服务的注册与发现，微服务的监控，微服务的限流相关等等，还有微服务怎么守护进程，我回答的是 supervisor，也不知道对不对。
具体业务的实现，兑换码的实现，如何批量生成几十万或者上百万的兑换码，（这个我回答的是用雪花算法实现），高并发下，一个兑换码如何保证只能被一个人兑换一次，以及一个兑换码如何可以被多个人兑换的实现。（这道题前前后后回答了有半个小时吧，因为之前做过相关的业务，所以心里有点底）
三个算法问题。
写一个方法，解决：输入 4 个数字，通过加减乘除，输出一个期望值。
广度优先算法：怎么输出各层的值。
台阶问题，假如对于上台阶，可以一次上一阶，也可以一次上两阶，写一个方法，实现输入台阶数，输出可以有多少种上法。